---
title: "Kapitel 1a: Datenaufbereitung Item Level"
format:
  html:
    df-print: kable
editor: source
---

```{r}
if (!require("pacman")) install.packages("pacman")
pacman::p_load(haven, psych,
               sjmisc, sjPlot, writexl,
               tidyverse, multilevelTools)
```


## Daten einlesen

```{r}
load("../data/df_cfa_wide.RData")
# add day here or already in data generation
```


## Daten ansehen

Der Datensatz hat 131 (!) Spalten (`ncol()`) und 100 Zeilen (`nrow()`) (eine pro Person). Aufgrund des breiten Datenformats gibt es so viele Spalten, da jeder Tag (1-10 Tage) von jeder Variable seine eigene Spalte bekommt.
Wie wir mit `names()` sehen, gibt es die Variablen id für die Personidentifikation (jede Person hat ihre eigene Nummer), a1-a5, b1-b5, und c1-c3. w,a,b und c bilden jeweils eine Skala mit 5 bzw. bei c 3 Indikatoren.
Mit `head()` können wir einen Blick in die Daten werfen.

```{r}
ncol(df_cfa_wide)
nrow(df_cfa_wide)
names(df_cfa_wide)
head(df_cfa_wide)
```

## Daten transformieren: Langformat

Als erstes transformieren wir die Daten vom Breit- ins Langformat, so dass jede Messung (Tag 1-Tag 10) eine eigene Zeile bekommt.
Im ersten Schritt machen wir den Datensatz seehr lang, es bekommt nämlich jede Messung von jeder Variable ihre eigenen Zeile.
Wir machen den Datensatz dann im zweiten Schritt wieder etwas breiter mit dem Ziel, eine Zeile pro Person und Tag zu bekommen, und jeweils eine Spalte pro Item.

Die Funktionsweise von pivot_longer() und pivot_wider() ist in https://methodenlehre.github.io/einfuehrung-in-R/chapters/04-tidyverse.html#4_3_reshaping beschrieben.

```{r}

df_cfa_superlong <- df_cfa_wide |> 
  pivot_longer(
    cols = -id, # All columns except id
    names_to = c("variable", "time"),
    names_sep = "_t"
  ) 

df_cfa_long <- df_cfa_superlong |> 
  pivot_wider(names_from = variable,
              values_from = value) |> 
  mutate(time = as.numeric(time)) # time geht von 1-10, wurde aber zuvor als Charakter abgespeichert

```

## Daten transformieren: Skalenscores erstellen

Als nächstes können wir die Skalenscores erstellen.

```{r}
df_cfa_long_scores <- df_cfa_long |> group_by(id, time) |> 
  summarise(
    a = rowMeans(across(starts_with("a")), na.rm = TRUE),
    b = rowMeans(across(starts_with("b")), na.rm = TRUE),
    c = rowMeans(across(starts_with("c")), na.rm = TRUE),
    .groups = "drop" # group_by() wieder aufheben für den finalen Datensatz
  )
```


## Daten transformieren: Zentrierung

Für die spätere Verwendung zerlegen wir die Rohvariablen mittels person-mean Zentrierung.
Wir zentrieren wir die Skalenvariablen, die täglich gemessen werden (aber nicht Baseline-Variablen), mittels `de_mean()`. de_mean() nimmt als Argumente (a) mit Komma getrennte Namen der Variablen, die wir zentrieren wollen (mehrere auf einmal ist möglich), (b) mittels grp Argument die identifizierende Variable für die Gruppenzugehörigkeit.


```{r}
df_cfa_long_scores <- df_cfa_long_scores |> 
  de_mean(a,b, c, grp = "id")
head(df_cfa_long_scores)

```

Als Ergebnis erhalten wir die zusätzlichen Variablen a, b, c jeweils mit "_dm" und "_gm". Was verbirgt sich dahinter? 
Wir haben einen Datensatz mit den unzentrierten / Rohvariablen der Skalen (ohne Suffix), den zentrierten Variablen (Suffix `_dm`) und den Mittelwerten der Personen (Suffix `_gm`), den wir zur weiteren Verwendung auch abspeichern.


Damit ist die Transformation der Daten abgeschlossen! Wir können den Datensatz nun abspeichern.

```{r}
save(df_cfa_long_scores, file = "../data/df_cfa_long_scores.RData")
```


## Überprüfe dein Verständnis

```{r}
df_cfa_long_scores |> filter(id == 1) |> select(id, time, a, a_dm, a_gm)
```

Warum ist der Wert für a_gm  in jeder Zeile gleich, nicht aber für a_dm und a? 
Wie müsste man a_dm und a_gm zusammensetzen, damit man auf a kommt?

## Übung





## Skalenbildung

```{r}
scales_within <- psych::scoreItems(keys = list(a = c("a1", "a2", "a3", "a4", "a5"),
                                                    b = c("b1", "b2", "b3", "b4", "b5"),
                                                    c = c("c1", "c2", "c3")) , df_example2)
scales_between <- psych::scoreItems(keys = list(w = c("w1", "w2", "w3", "w4", "w5")), df_w)
# join id and within
df_scores <- bind_cols(df_example2 |> select(id),
                       scales_within$scores)
# join between and within
df_scores <- scales_between$scores |> as_tibble() |> rownames_to_column(var = "id") |> mutate(id = as.numeric(id)) |> 
  right_join(df_scores, by = join_by(id))

```

## Abspeichern der gebildeten Skalen

Zum Schluss speichern wir die wichtigsten Objekte aus unserer R-Umgebung ab.

```{r}
save(df_scores, scales_between, scales_within, file = "data_scoring.RData")
```

