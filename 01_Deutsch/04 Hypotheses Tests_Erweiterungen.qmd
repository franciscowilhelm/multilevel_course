---
title: "Hypothesentests - Erweiterungen"
format:
  html:
    df-print: kable
editor: source
---

```{r}
if (!require("pacman")) install.packages("pacman")
pacman::p_load(lmerTest, haven, brms, psych,
               sjmisc, sjlabelled, sjPlot, writexl, broom.mixed, qgraph,
               tidyverse, multilevelTools, parameters, devtools)


load("../data/df_example1c.RData")


```

## Cross-Level Interaktion

%% zuerst repetieren Modell ohne Moderationseffekt %% 

Erwarten wir, dass der Effekt von täglichen Schwankungen in X auf Y abhängig von einer Variable ist, die auf Level-2 gemessen wird (z.B. relativ stabile Persönlichkeitsmerkmale), können wir dies mit einer Cross-Level Interaktion testen.

Level 1: $y_{ij} = \beta_{0j} + \beta_{1j}*(X_{ij}-\overline{X_j}) + \beta_{2j}*W_{j} + e_{ij}$

Level 2 (random intercept): $\beta_{0j} = \gamma_{00} + u_{0j}$
Level 2 (random slope for x): $\beta_{1j} = \gamma_{10} + u_{2j}$

```{r}
head(df_example1c)
```


```{r}
ri.rs_cli_modell <- lmer(y ~ x_dm + w + w*x_dm + (1 + x_dm | id), data = df_example1c)
model_parameters(ri.rs_cli_modell) |> print_html()
```
Beachtet, dass mit der eingebauten Interaktion die Haupteffekte nicht mehr interpretiert werden.

### Visualisierung

Visualisierung des Interaktionseffekt mittels der `plot_model()` Funktion.
Standardmässig werden die Simple Slopes an den Extremwerten (Minimum, Maximum) des Moderators geschätzt.

```{r}
plot_model(ri.rs_cli_modell, type = "int", terms = c("x_dm", "w"))
ggsave("test.png")
```

Alternativ kann man auch die Werte zum Mittelwerte und bei -1 SD und +1 SD des Moderators anzeigen lassen.

```{r}
plot_model(ri.rs_cli_modell, type = "int", mdrt.values = "meansd")
```
Der Plot zeigt, dass bei höheren Ausprägungen von w der Effekt von x_dm stärker ausfällt.


### Within-level Interaktion

Analog zur Cross-level Interaktion gibt es auch Within-level Interaktionen, bei der die Level-1 Anteile von Prädiktorvariablen miteinander interagieren.

Level 1: $y_{ij} = \beta_{0j} + \beta_{1j}*(X_{ij}-\overline{X_j}) + \beta_{2j}*(M_{ij}-\overline{M_j}) + \beta_{3j}*((M_{ij}-\overline{M_j})*(X_{ij}-\overline{X_j})) + e_{ij}$

Level 2 (random intercept): $\beta_{0j} = \gamma_{00} + u_{0j}$
Level 2 (random slope X): $\beta_{1j} = \gamma_{10} + u_{1j}$
Level 2 (random slope M): $\beta_{2j} = \gamma_{20} + u_{2j}$

```{r}
ri.rs_wli_modell <- lmer(y ~ x_dm + m_dm + x_dm*m_dm + (1 + x_dm + m_dm | id), data = df_example1)
model_parameters(ri.rs_wli_modell) |> print_html()
```

```{r}
plot_model(ri.rs_wli_modell, type = "int", mdrt.values = "meansd")
```

Der Interaktionseffekt ist nicht signifikant. Dies bedeutet, wie der Plot zeigt, dass die Linien bei allen Ausprägungen des Moderators mehr oder wenig parallel sind.
 
## Übung

Wir arbeiten in der Übung mit einem neuen Datensatz.

Mache dich mit ihm vertraut.
Diesmal benutzen wir einen Datensatz in dem die Variablen "labelled" sind, also Beschriftungen haben. Wir können die Labels mit `get_label()` abrufen.

```{r}
load("../data/df_example_cli.RData")

head(df_example_cli)
get_label(df_example_cli)
# alternativ
view_df(df_example_cli)
```

Berechne Modelle mit denen du die folgenden Hypothesen testest: 

H1: Illegitime Aufgaben hängen positiv mit negativem Affekt zusammen.
H2: Der positive Zusammenhang von illegitime Aufgaben mit negativem Affekt fällt schwächer aus, wenn Unterstützung von Kolleg:innen hoch ausgeprägt ist.

Gehe Schritt für Schritt vor und teste erst in einem Modell H1, dann in einem anderen Modell H2.
Urteile, ob die Hypothesen angenommen oder verworfen werden sollten.

:::{.callout-tip collapse="true"}

```{r}
ri.rs_modell <- lmer(negativ ~ illtask_dm  + support + (1 + illtask_dm | id), data = df_example_cli)
parameters(ri.rs_modell)
```
Der Zusammenhang von täglichen illegitimen Aufgaben (illtask_dm)  mit negativem Affekt (negativ) ist signifikant (b = 0.33, p < .001), was Hypothese 1 unterstützt.

```{r}
ri.rs_cli_modell <- lmer(negativ ~ illtask_dm  + support*illtask_dm + (1 + illtask_dm | id), data = df_example_cli)
parameters(ri.rs_cli_modell)

```
Der Interaktionseffekt von täglichen illegitimen AUfgaben mit sozialer Unterstützung durch Kolleg:innen auf negativen Affekt ist nicht signifikant (b = -0.01, p = .89). Hypothese 2 muss somit verworfen werden.

:::{.callout-tip collapse="true"}


## Daten einlesen

```{r}
load("../data/df_example1.RData")
```
Im Folgenden erstellen wir ein Mediationsmodellen und spezifizieren bei den Argumenten x, y, und m die die unabhängige, abhängige, und mediierende Variable. Für die abhängige Variablen wählen wir die Rohvariable, für unabhängige und mediierende Variablen die personen-zentrierten Variablen.


## Maximum Likelihood Variante

### 1-1-1 Mediation

```{r}
fit_mediation <- multilevelmediation::modmed.mlm(df_example1, "id", "x_dm", "y", "m_dm",
                                random.int.m = FALSE,
                                na.action = na.omit)

summary(fit_mediation$model)
```
### Bootstrapped Version

```{r}
boot.custom.results <- boot.modmed.mlm.custom(
  data = df_example1,
  L2ID = "id",
  X = "x_dm",
  Y = "y",
  M = "m_dm",
  random.int.m = FALSE,
  control = list(opt = "nlm"),
  na.action = na.omit,
  return.type = "all",
  nrep = 1000,
  parallel.type = "parallel",
  ncores = 4,
  seed = 2299)

```

```{r}
summary(boot.custom.results$model)
extract.modmed.mlm(boot.custom.results, type="all")
extract.modmed.mlm(boot.custom.results, type="indirect")
# manual extract of CI
indirect_boot <- tibble(SyM = boot.custom.results[["t"]][,which(names(boot.custom.results[["t0"]]) == "SyM")], 
                        SmX = boot.custom.results[["t"]][,which(names(boot.custom.results[["t0"]]) == "SmX")]) |> 
  mutate(indirect = SyM * SmX)
quantile(indirect_boot$indirect, c(0.025, 0.975), na.rm = TRUE)

```

Das Paket gibt aktuell keine aus den Bootstrap ermittelte Konfidenzintervalle des indirekten Effekts aus, aber wir können sie aus den Bootstrap Results berechnen.

### 1-1-1 Mediation mit Moderation

```{r}
fit_modmed.mlm <- multilevelmediation::modmed.mlm(df_example1, "id", "x_dm", "y", "m_dm", "w", moderator = "w", mod.a = TRUE,
                                random.int.m = FALSE,
                                na.action = na.omit)

summary(fit_modmed.mlm$model)

fit_modmed.mlm_glmmtmb <- multilevelmediation::modmed.mlm(df_example1, "id", "x_dm", "y", "m_dm", "w", moderator = "w", mod.a = TRUE,
                                random.int.m = FALSE,
                                na.action = na.omit,
                                estimator = "glmmTMB")

summary(fit_modmed.mlm_glmmtmb$model)
```

```{r}
# extract.modmed.mlm(fit_modmed.mlm_glmmtmb, type="indirect.diff", modval1 = 1, modval2 = 5)
```


## Bootstrapped moderated within-person mediation
 
```{r}
library(parallel)
library(boot)
library(multilevelmediation)
ncpu<-2
RNGkind("L'Ecuyer-CMRG") # set type of random number generation that works in parallel
cl<-makeCluster(ncpu)
clusterSetRNGStream(cl, 42) # set random number seeds for cluster


# boot.result<-boot(df_example1, statistic=boot.modmed.mlm, R=10,
#                   L2ID = "id", X = "x_dm", Y = "y", M = "m_dm", moderator = "w", mod.a = TRUE,
#                   modval1 = 1, modval2 = 5,
#                                 random.int.m = FALSE,
#                                 na.action = na.omit,
#   type="all",
#   control=list(opt="nlm"),
#   parallel="snow",ncpus=ncpu,cl=cl)

# trace(stack_bpg, browser, at = 1)
# untrace(stack_bpg)
# trace(modmed.mlm, browser, at = 1)
# untrace(modmed.mlm)
boot.custom.results <- boot.modmed.mlm.custom(
  data = df_example1,
  L2ID = "id",
  X = "x_dm",
  Y = "y",
  M = "m_dm",
  moderator = "w",
  mod.a = TRUE,
  mod.b = FALSE,
  mod.cprime = FALSE,
  random.int.m = FALSE,
  control = list(opt = "nlm"),
  na.action = na.omit,
  return.type = "all",
  modval1 = 1,
  modval2 = 5,
  nrep = 500,
  parallel.type = "parallel",
  ncores = 4,
  seed = 2299)


```
 
 

```{r}
boot.custom.results[["model"]]
extract.boot.modmed.mlm(boot.custom.results, type="indirect", ci.conf=.95)
extract.boot.modmed.mlm(boot.result, type="indirect.diff", modval1 = 1, modval2 =5, ci.conf=.95)


# extract.boot.modmed.mlm(boot.result, type="indirect.diff", ci.conf=.95)
```

multilevelmediation is still in alpha and many functions dont return errors or weird results.

### Bayes Variante mit brms

Diese Berechnung dauert (bei mir 5-10 Minuten). Daher speichere ich sie hier ab, um sie nicht jedes mal neu ausfuehren zu muessen.
Die Funktion setzt unter Windows RTools voraus, unter MacOS, Siehe https://learnb4ss.github.io/learnB4SS/articles/install-brms.html


```{r}
#| eval: false
#| # setzt Rtools voraus
fitbayes <- mlmediation_wrapper(x = "x_dm",
                                y = "y",
                                m = "m_dm",
                                id = "id",
                                df = df_example1,
                                randomcor = FALSE) # dauert

save(fitbayes, file = "cache/fitbayes.RData")
```



Ergebnisdarstellung:
(Die folgende Syntax muss nicht angepasst werden.)
```{r}
load("fitbayes.RData")

# summary(fitbayes)
tidy(fitbayes, effects = c("fixed")) |> mutate(across(where(is.numeric), ~round(.x,2)))
extract_indirect(fitbayes)
```
Dies ergibt zwei Outputs. Der erste (von der Funktion `tidy()`) beinhaltet die fixed effects.
SmX = a-Pfad SyM = b-Pfad SyX = c'-Pfad.

Es werden keine p-Werte angegeben, da es sich um bayessche Schätzungen handelt. Der 95% Credibility Interval gibt Auskunft, ob ein Effekt signifikant ist.

Der zweite (von der Funktion `extract_indirect()`) beinhaltet den kalkulierten indirekten Effekt.
 = a\*b, indirekter Effekt.
 


 